package org.chapter7.ex;

/*
    패키지
    클래스의 묶음, 클래스 또는 인터페이스를 포함시킬 수 있음
    서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있음
    - 같은 이름의 클래스라도 서로 다른 패키지에 존재하는 것 가능
    패키지는 물리적으로 하나의 디렉토리
 */

/*
    제어자(modifier)
    접근 제어자 - public, protected, (default), private
    그 외 - static, final, abstract, ...
    
    static
    '클래스의' 또는 '공통적인'의 의미
    인스턴스 변수는 하나의 클래스로부터 생성되었더라도 각기 다른 값을 유지
    클래스 변수는 인스턴스에 관계없이 값을 가짐 -> 하나의 변수를 모든 인스턴스가 공유
    사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭

    final
    '마지막의' 또는 '변경될 수 없는'의 의미
    변수에 사용되면 값을 변경할 수 없는 상수
    메서드에 사용되면 오버라이딩을 할 수 없게됨
    클래스에 사용되면 자신을 확장하는 자손 클래스를 정의하지 못하게됨
    사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수
    ex) String, Math
    
    abstract
    '미완성'의 의미
    메서드의 "선언부만 작성"하고 실제 수행내용은 구현하지 않는 추상 메서드를 선언하는데 사용
    클래스에 사용되어, 클래스 내에 추상메서드가 존재한다는 것을 쉽게 알 수 있게 함
    사용될 수 있는 곳 - 클래스 ,메서드
    인스턴스 생성 불가능

    접근 제어자(access modifier)
    해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할
    접근 제어자가 지정되어 있지 않으면 default
    사용될 수 있는 곳 - 클래스, 멤버변수, 메서드, 생성자
    - private (같은 클래스 내 접근O)
    - default (같은 패키지 내 접근O)
    - protected (같은 패키지 내, 다른 패키지의 자손 클래스에서 접근 O)
    - public (접근 제한X)

    접근 제어자 사용 이유
    - 외부로부터 데이터를 보호하기 위해서
    - 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서
    => 데이터 감추기라고 하며, 캡슐화에 해당하는 내용
 */

/*
    다형성
    여러 가지 형태를 가질 수 있는 능력
    한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 함
    => 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록함

    1. 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있다.
    2. 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다. (참조변수가 사용할 수 있는 멤버 개수가 더 많으면 안됨)
 */

/*
    참조변수의 형변환
    서로 상속관계에 있는 클래스 사이에서 가능
    자손 타입의 참조변수 <-> 조상타입의 참조변수 => 모든 참조변수는 모든 클래스의 조상인 Object 클래스 타입으로 형변환 가능!
    조상 <- 자손 형변환 생략가능 => 조상타입으로 형변환하면 다룰 수 있는 멤버의 개수가 줄어들기 때문에 항상 안전함
    자손 <- 조상 형변환 생략불가
    - 변수에 저장된 값(주소값)이 변환되는 것이 아니다

   - 참조 변수가 가리키는 인스턴스의 자손타입으로 형변환은 허용되지 않는다.
   - 그래서 참조변수가 가리키는 인스턴스의 타입이 무엇인지 확인하는 것이 중요하다!

   참조변수의 형변환은 인스턴스에 아무런 영향을 미치지 않는다.
   단지 참조변수의 형변환을 통해서, 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것 뿐이다.

 */

/*
    instanceof 연산자
    참조변수의 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해 instanceof 연산자를 사용한다.
    주로 조건문에 사용되며, 연산의 결과로 boolean 값을 반환한다.
    // 참조변수 instanceof 타입(클래스명)
    => instatnceof가 true면 참조변수가 검사한 타입으로 형변환이 가능하다는 뜻이다.
    
 */

public class Ex7_7 {
    
    void dowork(Car c) {
        // 이 메서드가 호출될 때, 매개변수로 Car 클래스 또는 그 자손 클래스의 인스턴스를 넘겨받겠지만,
        // 메서드 내에서는 정확히 어떤 인스턴스인지 알 길이 없다.
        if(c instanceof FireEngine) {   // 형변환이 가능한지 확인
            // 참조변수 c가 가리키고 있는 인스턴스의 타입 체크
            FireEngine fe = (FireEngine)c; // 자손 <- 조상 형변환
            fe.water();
        }
        // 참조변수의 타입과 인스턴스의 타입이 항상 일치하지 않음
        // 조상타입의 참조변수로는 실제 인스턴스의 멤버들을 모두 사용할 수 없기 때문에,
        // 실제 인스턴스와 같은 타입의 참조변수로 형변환을 해야만 인스턴스의 모든 멤버들을 사용할 수 있음
    }
    
    public static void main(String[] args) {

        // 다형성
        Tv t = new SmartTv();   // 타입 불일치, 조상 타입의 참조변수로 자손 인스턴스 참조
        SmartTv s = new SmartTv();
        // => SmartTv 인스턴스 2개 생성, 참조변수 s와 t가 생성된 인스턴스를 하나씩 참조함

        /*
        !!!! 실제 인스턴스가 SmartTv타입이라 할지라도, 참조변수 t로는 SmartTv 인스턴스의 모든 멤버를 사용할 수 없다!
        Tv 타입의 참조변수로는 SmartTv 인스턴스 중에서 Tv클래스의 멤버들만 사욯알 수 있다
        => 생성된 SmartTv 인스턴스의 멤버 중에서 Tv 클래스에 정의 되지 않은 멤버, text와 caption()은 참조변수 t로 사용 불가능하다.

        => t.text   t.caption() 불가!!
        => 둘 다 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라진다!
        */





        Car car = null;
        FireEngine fe = new FireEngine();
        FireEngine fe2 = null;
        // 참조변수 car와 fe는 타입이 다르기 때문에, 대입연산을 수행하기 전에 형변환을 수행하여 두 변수간의 타입을 맞춰야 함

        fe.water();
        car = fe;   // car = (car)fe; 에서 형변환 생략
        // 참조변수 fe가 참조하고 있는 인스턴스를 참조변수 car가 참조하도록 한다. fe값이 car에 저장된다. 이 때 두 참조변수의 타입이 다르므로 참조변서 fe가 형변환되어야 하지만 생략되었다.
        // 참조변수 car를 통해서도 FireEngine인스턴스를 사용할 수 있지만, fe와 달리 car는 Car타입이므로 Car클래스의 멤버가 아닌 water()는 사용할 수 없다.
        // => car로는 water() 메소드 사용 불가!!


        fe2 = (FireEngine) car; // 자손타입 <- 조상타입 형변환 생략 불가
        // 참조변수 car가 참조하고 있는 인스턴스를 참조변수 fe2가 참조하도록 한다
        // car에는 FireEngine인스턴스의 주소가 저장되어 있으므로 fe2에도 FireEngine인스턴스의 주소가 저장된다.
        // 이제는 참조변수 fe2를 통해서도 FireEngine인스턴스를 사용할 수 있지만, car와 달리, fe2는 FireEngine타입이므로 FireEngine인스턴스의 모든 멤버들을 사용할 수 있다.
        // => 형변환하여 car에서 사용못하는 water() 메소드 사용가능해짐
        fe2.water();




        Car car3 = new Car();
        Car car4 = null;
        FireEngine fe3 = null;

        car3.drive();
//        fe3 = (FireEngine) car3;    // 컴파일은 가능하지만 실행시 에러 발생!!!!!
//        fe3.drive();
        // 형변환 오류 때문이다!
        // 참조변수 car3가 참조하고 있는 인스턴스가 Car 타입의 인스턴스이기 떄문이다
        // => 조상타입의 인스턴스를 자손타입의 참조변수로 참조하는 것은 허용되지 않는다.
        car4 = fe3;
        car4.drive();
    }
}

class Tv {

    // Tv의 속성(멤버변수)
    String color;
    boolean power;
    int channel;

    // Tv의 기능(메서드)
    void power() {
        power = !power;
    }

    void channelUp() {
        ++channel;
    }

    void channelDown() {
        --channel;
    }
}

class SmartTv extends Tv {
    String text; // 캡션을 보여 주기 위한 문자열
    void caption(){}
}


class Car {
    String color;
    int door;

    void drive() {
        System.out.println("drive~");
    }

    void stop() {
        System.out.println("stop!!");
    }
}

class FireEngine extends Car {  // 소방차
    void water() {  // 물 뿌리기 기능
        System.out.println("water~!");
    }
}
