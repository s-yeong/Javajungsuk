package org.chapter11.ex;

public class Ex11_1_LinkedList {
}

/*
    배열의 장점
    배열은 가장 기본적인 형태의 자료구조
    간단하며 사용하기 쉽고 데이터를 읽어 오는데 걸리는 시간이 가장 빠름

    배열의 단점
    1. 크기를 변경할 수 없다(실행 중에 바꿀 수 없음)
    - 크기를 변경할 수 없으므로 새로운 배열을 생성해서 데이터를 복사해야함 (1. 더 큰 배열 생성 2. 복사 3. 참조 변경)
    - 실행 속도를 향상시키기 위해서는 충분히 큰 크기의 배열을 생성해야 하므로 메모리 낭비
    2. 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸림
    - 차례대로 데이터를 추가하고 마지막부터 데이터를 삭제하는것은 빠르지만,
    - 배열의 중간에 데이터를 추가하려면, 빈자리를 만들기 위해 다른 데이터들을 복사해서 이동해야함

    단점 보완 -> LinkedList
    배열 - 모든 데이터 "연속적"으로 존재 <->
    링크드 리스트 - "불연속"으로 존재하는 데이터를 서로 연결(link)한 형태로 구성
    (어떤 데이터가 있으면 그 다음 데이터가 바로 옆에 있는게 아님)

    - 각 요소(node)들은 자신과 연결된 다음 요소에 대한 참조와 데이터로 구성되어 있음
    class Node {
        Node next;  // 다음 요소의 주소를 저장
        Object obj; // 데이터를 저장
    }

    LikedList의 추가와 삭제
    - 삭제하고자 하는 요소의 이전 요소가 삭제하고자 하는 요소의 다음 요소를 참조하도록 변경!
    => 단 하나의 참조만 변경하면 삭제가 이루어짐
    (배열처럼 데이터를 이동하기 위해 복사하는 과정이 없기 때문에 처리속도가 매우 빠름)
    - 새로운 데이터를 추가할 때는 새로운 요소를 생성한 다음,
    추가하고자 하는 위치의 이전 요소의 참조를 새로운 요소에 대한 참조로 변경하고,
    새로운 요소가 그 다음 요소를 참조하도록 변경! (처리속도 매우 빠름)

    ArrayList와 LinkedList 비교
    배열의 경우 인덱스가 n인 원소의 값을 얻어 오고자 한다면,
    => 인덱스가 n인 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기
    ex) Object[] arr = new Object[5];
    arr[2]에 저장된 값 읽으려면 -> n은 2, 크기 4byte, 배열의 주소 0x100이므로 => 0x108이 된다.
    => 배열은 각 요소들이 연속적으로 메모리상에 존재하기 때문에 이처럼 간단한 계산만으로
    원하는 요소의 주소를 얻어서 저장된 데이터를 곧바로 읽어올 수 있지만,
    <=>
    LinkedList는 불연속적으로 위치한 각 요소들이 서로 연결된 것이라
    처음부터 n번째 데이터까지 차례례대로 따라가야만 원하는 값을 얻을 수 있다.
    => 저장해야하는 데이터의 개수가 많아질수록 데이터를 읽어 오는 시간, 접근시간이 길어진다는 단점이 있다.

    <배열기반 - 연속>
    ArrayList - 읽기(접근시간) => 빠르다,    추가/삭제 => 느리다,   순차적인 추가삭제는 빠름, 비효율적인 메모리 사용
    <연결기반 - 불연속>
    LinkeList - 읽기(접근시간) => 느리다,    추가/삭제 => 빠르다,   데이터가 많아질수록 접근성 떨어짐

 */

/**
 * 다르고자 하는 데이터 개수가 변하지 않는다 => ArrayList 사용
 * 데이터 개수의 변경이 잦다 => LinkedList 사용
 */
