package org.chapter14.ex;

/*
    함수와 메서드 차이
    - 근본적으로 동일, 함수는 일반적 용어, 메서드는 객체지향개념 용어
    - 함수는 클래스에 독립적, 메서드는 클래스에 종속적 - 자바에서는 무조건 메서드는 클래스 안에 있어야함
 */

/*
    람다식 (Lambda Expression)
    함수(메서드)를 하나의 식(expression)으로 표현한 것
    - 함수를 간략하면서도 명확하게 표현할 수 있게해줌
    - '익명 함수'라고도 함 (메서드를 람다식으로 표현하면 메서드의 이름과 반환값이 없어지므로)

    - 람다식이 간결하면서도 이해하기 쉬움
    모든 메서드는 클래스에 포함되어야 하므로 클래스도 새로 만들어야 하고,
    객체도 생성해야만 비로소 이 메서드를 호출할 수 있음
    => 람다식은 이 모든 과정없이 오직 람다식 자체만으로도 이 메서드의 역할을 대신할 수 있음
    
    - 메서드의 매개변수로 전달되어지는 것이 가능, 메서드의 결과로 반환될 수도 있음
    => 메서드를 변수처럼 다루는 것이 가능해짐
 */

/*
    람다식 작성하기

    // 메서드
    int max(int a, int b) {
        return a > b? a : b;
    }

    // => 람다식
    // 이름과 반환타입 제거(max, int), 매개변수 선언부와 몸통{}사이에 '->' 추가!
    1. (int a, int b) -> { return a > b? a : b; }

    반환값이 있는 메서드의 경우, return문 대신 "식"으로 대신할 수 있음
    => 식의 연산결과가 자동적으로 반환값이 된다
    2. (int a, int b) -> a > b? a : b

    람다식에 선언된 "매개변수의 타입"은 추론이 가능한 경우 생략할 수 있다. (대부분의 경우 생력 가능)
    (람다식에 반환타입이 없는 이유도 항상 추론이 가능하기 때문!)
    3. (a, b) -> a > b? a : b

    선언된 매개변수가 하나뿐인 경우 괄호()를 생략할 수 있음
    단, 매개변수의 타입이 있으면 괄호()생략 불가
    a -> a * a          int a -> a * a // 에러

    괄호{} 안의 문장이 하나일 때 괄호{} 생략할 수 있음
    *** 문장의 끝에 ';' 붙이지 않아야 하는 거 주의!!! ***
    (String name, int i) ->
        System.out.println(name + "=" + i)
    단, 괄호{} 안의 문장이 return 문일 경우 생략 불가능!

 */

/*
    람다식은 어떤 클래스에 포함?
    => "익명 클래스의 객체"와 동등함 ( 메서드와 동등한 것이 아님 )

    (int a, int b) -> a > b ? a : b         => "객체"!!!

    <->
    new Object() {  // 익명 클래스는 객체의 선언과 생성을 동시에
        int max(int a, int b) {
        return a > b ? a : b;
    }   메서드 이름 max는 임의로 붙인 것일 뿐 의미 X

    익명 객체의 메서드를 어떻게 호출?
    => "참조변수"가 있어야 객체의 메서드를 호출할 수 있다!
    타입 f = (int a, int b) -> a > b? a : b;
    - 참조형이니까 클래스 또는 인터페이스가 가능
    - 람다식과 동등한 메서드가 정의되어 있는 것이어야 한다! (그래야 참조변수로 익명 객체의 메서드를 호출할 수 있음)
    (타입 f에서 타입에 동등한 메서드가 정의되어 있어야함)

 */

class Ex14_0_LambdaExpression {
    public static void main(String[] args) {


        MyFunction2 f2 = (a, b) -> a > b ? a : b;
        // 람다식(익명 객체)을 다루기 위한 참조변수의 타입은 함수형 인터페이스로 한다!
        // 매개변수 타입 + 반환 타입 같아야함
        // => 추상메서드를 통해 람다식을 호출한다

        MyFunction2 f = new MyFunction2() {
            public int max(int a, int b) {  // 오버라이딩 규칙!! 접근제어자는 좁게 못바꿈
                return a > b ? a : b;
            }
        };

        // 실제로 람다식은 메서든데, 호출하려면 이름이 필요
        int value = f2.max(3,5);
        System.out.println("value = " + value);
        // 참조변수 obj의 타입이 Object인데,
        // Object의 타입엔 max라는 메서드가 없다!
        // => 함수형 인터페이스 필요
    }
}

@FunctionalInterface
interface MyFunction2 {
    int max(int a, int b);
}
